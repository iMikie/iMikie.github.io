<!DOCTYPE html>
<head>
    <title> think.build </title>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="../content-stylesheet.css">
</head>

<iframe id="index-of-posts" src="blog-index-of-posts.html">
</iframe>


<div id="nameplate">
    Mike Farr
    <p id="title-style">A Dev BootCamp Cultural Post
    </p>
</div>

<header id="headsp">
    The Tyranny of the Command Line
</header>
<br>
<div id="inset1984">"When you use the command line, you don&#39;t slow yourself down opening a finder and double-clicking
    on folders. Instead, you get to navigate around your computer, open, create, delete, move, files, etc. all using
    commands."
    <p id="cmline"> --from an introduction to learning the Command Line</p>

</div>

<main>

    <img src="imgs/1984.png" alt="Blackwhite and double think" width="525px"/>


    <h2>Blackwhite. Wow.</h2>

    <p>
        When I read the above quote on learning the command line I immediately thought of
        George Orwell and his brilliant description of <strong>blackwhite</strong> from "1984".
    </p>

    <p>
        To be fair, this statement was likely meant to be motivating or at least a fear reducing, "Now this won't hurt a bit." Still,
        come to think of it, isn't that what doctors say to patients before doing something <strong><em>that will
        hurt alot?</em></strong>
    </p>

    <p>It was once my job to measure this.  In the late 80's and early 90's I worked at Apple. One of my early jobs was as a product manager for UNIX and for
        the <em>Macintosh Programmer's Workshop</em>, a development system which was mostly a
        command line affair but which did UNIX one (or more) better. We studied the time it took to do
        simple and complax tasks.</p>
    <h4 id="toc_1">Testing the new way.</h4>

    <p>GUI based IDEs were just coming out: Lightspeed C and Pascal (then Metrowerks, then NextStep, then XCode.)
        (For a modern equivalent see
        <a href="http://www.youtube.com/watch?v=86rnZ_xsZDE"> a video review of RubyMine</a>) You probably don't
        know those those IDE's but we deeply studied file navigation as mentioned in the quote. A
        user in
        a GUI clicks to open folders,
        clicks or drags to select multiple files, then drags, hovers over a
        folder to have it automatically open and then drops the file(s). A command line user types a list of
        commands.

    <div class="grey_code"> cd; <br>
        ls; <br>
        cd <em>path</em><br>
        ls;<br>
        cp <em>regex path</em><br>
        stop...what was that destination path?<br>
        cp <em>regex path</em><br>
    </p>
    ...
    </div>

    <p>The GUI was 10 times faster than the command line.  In the hands of a novice user it was the difference between
getting something done and getting nothing done.  Surprisingly to some, though, even with command
line experts <strong>the more complex the task, the more the
        GUI won.</strong> The command line guys were pretty darn fast too. Our
        laptop keyboards today are built to be thin, not fast.  If you've ever felt the joy of blazing on a real keyboard you know what I mean...sigh.</p>

    <p> And we never had to restore a GUI user's system from backup while command line file manipulation
        errors had a tendency to go catastrophic. Imaging combining the most destructive task -- file deletion, with
        the most cryptic, error prone command structure -- regular expressions. It was like the joke where the civil
        engineer tells the doctor and lawyer that in fact God must be civil engineer because who else would route a waste
        disposal system through a recreational area?  The command line guys made fun of the GUI user's desktop and
        Trash can but they couldn't undo an rm.</p>

    <h3 id="toc_3">Resource building <img src="imgs/ResEdit.png" alt="ResEdit"/>
    </h3>

    <p>Here's a funny story. Our little resource
        editor,
        ResEdit, got no love. Resources are little bits of code, sometimes visual or with color attributes or a design
        like an icon. RedEdit was actually a collection of editors, each specialized to it's task. It was a GUI tool
        which was loved by external developers but reviled by the text and command line crowd internally. Only wimps
        used it. It wasn't professional. </p>

    <p class="embedded_aside">
        Real men don't use ResEdit.
    </p>

    <p>The guy who maintained it got no respect. There were plans to cut it. Then an interesting thing happened. </p>

    <p>We decided to do an informal survey. I think it was to CYA before killing ResEdit.
        We used a little known fact that for debugging purposes, ResEdit embedded a version string in the binary of the
        resources it made. You could therefore tell by looking at the file data for a resource if ResEdit made it.
    </p>

    <p>
        Surprise! Most resources, even those created by those in the anti-ResEdit camp were
        created using ResEdit. When the doors were closed and no one was looking, programmers went back and used the GUI
        tool.</p>

    <p>The real strength of the GUI was not speed but the fact that you didn't have to memorize a bazillion arcane bits
        of info just to get anything done. It allows you to see what you are doing. Even a lowly dialog box reminds you of
        what the options are and what their legal values are without having to read some of the most poorly written prose in the English language: "man" pages.


    <p class="embedded_aside">
        Is man-page content generated entirely from capcha's?
    </p>


    <p>
        A GUI, even if it's just a dialog box, allows you to do things you&#39;re
        not sure how to do without having to spend hours in research. The
        command line just sits there and dares you to perfectly type the exact arcane commands. Discovery is
        painful.</p>

    <h3 id="toc_2">When Keyboard Centric Works</h3>

    <p>We did find cases where the keyboard was faster, but really it wasn't the command line per-se, it was a  keyboard
        centric approach that was fastest. </p>

    <p>Editing text where fonts and styles don't matter, where the program auto-formats and colorizes,
        e.g. the user doesnâ€™t put in bold, italic colors and
        font sizes, or layout, and where the content is structured programming code.  Now you have a different game. It's a limited
        domain and can be optimized. </p>

    <p>Moving around in a small environment of files such as a project can be faster using only the keyboard <strong>
        providing you memorize the entire structure</strong> or, like Rails, it's a limited domain and the structure
        doesn't
        change, i.e no need of discovery.
    </p>

    <p>
        Sublime Text is a wonderful example. They have spent a lot of time thinking
        about how fast you can move around in this limited domain and never take your hand off the keyboard. As you
        auto-complete file names you only need to type the letters that make a filename unique, something a human mind
        is astoundingly good at. "p0u2" uniquely identifies "phase-0-unit-2" and you are not limited to the current
        directory.
        Sublime is looking throughout your project. As you do this files are opened in the background so that when you
        have a unique match it's already
        open.</p>

    <h3 id="toc_4">Hybrid Designs</h3>

    <p>Often at Apple we found there was a simple hybrid solution gave the best of both. I think it was shift-return that
        would open a dialog box that
        would let you tab through the arcane options that no one remembers. I'd love this for git when I need to fork, pull, or reset the head. A
        dialog can remind the user of the available options when
        typing an unfamiliar complex command can be a nightmare. The <em>Macintosh Programmers' Workshop</em> had this
        and it was
        one of it's best features. I often wonder if this could be adopted for linux. </p>


    <h3 id="toc_5">It&#39;s Old Tech</h3>

    <p>The truth is that command line interpreters are 60&#39;s tech; they were invented before technology allowed for
        anything else. When there was no wysiwyg or drag and drop, no notion of encapsulating a command into a button, a
        file into an icon. Once you have been forced to learn such a thing it becomes a badge of honor. A reason why you
        are better than the other guy. </p>

    <p>This happens a lot in the tech world. There is a tremendous reticence to give up a skill that elevates you in
        status above others in some way, even if there is a better, stronger, faster way. <strong>Call it the narcissism of the command
            line..</strong> If  there's an easier way that requires little training and you've spent years learning
            the hard way, that's just not good news. So some hold stubbornly to the old as you "get to navigate with commands".
            Yeah, and we all want to go back to DOS.  I can hear the stampede.
            uckily there are innovations being made by companies like Sublime text but as long as I have to switch
            environments just to debug and type in debugger statements instead of just read my IDE's watch panel,
            I'll stick with RubyMine and learn Vintage.  Modern
        easy,
        fast, and beautiful interfaces are all around you. Let&#39;s not call the page black and the type white...unless of course
        you've customized your editor's theme that way.  </p>
    <footer>
        <p> Mike Farr
            <br>
            <em>Everything that's interesting to do was once impossible.</em>
            <br>
            April 12, 2015
        </p>
    </footer>
</main>

